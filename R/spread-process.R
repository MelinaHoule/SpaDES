##############################################################
#' Simulate a spread process on a landscape.
#'
#' This can be used to simulated fires or other things. Essentially, it starts from a collection of cells
#' (\code{loci}) and spreads to neighbours, according to the \code{directions} and \code{spreadProbPixel} arguments.
#' This can become quite general, if \code{spreadProbPixel} is 1 as it will expand from every loci until all pixels
#' in the landscape have been covered. With \code{mapID} set to \code{TRUE}, the resulting map will be
#' classified by the index of the pixel where that event propagated from. This can be used to examine things like
#' fire size distributions.
#'
#' @param landscape     A \code{RasterLayer} object.
#'
#' @param loci          A vector of locations in \code{landscape}
#'
#' @param spreadProbPixel    Numeric or rasterLayer. The overall probability of spreading, or probability raster
#' driven.
#'
#' @param persistence   A probability that a burning cell will continue to burn, per time step.
#'
#' @param mask          non-NULL, a \code{RasterLayer} object congruent with \code{landscape}
#'                      whose elements are \code{0,1}, where 1 indicates "cannot spread to". Currently
#'                      not implemented.
#'
#' @param maxSize       Vector of the maximum number of pixels for a single or all events to be spread.
#'                      Recycled to match \code{loci} length.
#'
#' @param directions    The number adjacent cells in which to look; default is 8 (Queen case).
#'
#' @param iterations    Number of iterations to spread. Leaving this \code{NULL} allows the spread
#'                      to continue until stops spreading itself (i.e., exhausts itself).
#'
#' @param ...           Additional parameters.
#'
#' @return A \code{RasterLayer} indicating the spread of the process in the landscape.
#'
#' @import raster
#' @export
#' @docType methods
#'
#' @author Steve Cumming \email{Steve.Cumming@@sbf.ulaval.ca}
#' @author Eliot McIntire
#'
#' @name spread
#' @aliases spread
#' @rdname spread
#'
setGeneric("spread", function(landscape, loci=ncell(landscape)/2L, spreadProbPixel=0.23,
                              persistence=0L, mask=NULL, maxSize=rep_len(ncell(landscape), length(loci)),
                              directions=8L, iterations=NULL, ...) {
  standardGeneric("spread")
})

#' @param plot.it    If TRUE, then plot the raster at every iteraction, so one can watch the
#' spread event grow.
#'
#' @param mapID  Logical. If TRUE, returns a raster of events ids. If FALSE,
#' returns a raster of iteration numbers, i.e. the spread history of one or more events.
#'
#' @importFrom methods is
#' @import raster
#' @import RColorBrewer
#' @rdname spread
#'
#' @examples
#' library(raster)
#' library(RColorBrewer)
#'
#' # Make random forest cover map
#' a <- raster(extent(0,1e2,0,1e2),res=1)
#' hab <- gaussMap(a,speedup=1) # if raster is large (>1e6 pixels), use speedup>1
#' names(hab)="hab"
#' cells <- loci <- b <- as.integer(sample(1:ncell(a),1e1))
#' mask <- raster(a)
#' mask <- setValues(mask, 0)
#' mask[1:5000] <- 1
#' numCol <- ncol(a)
#' numCell <- ncell(a)
#' directions <- 8
#'
#' # Transparency involves putting 2 more hex digits on the color code, 00 is fully transparent
#' setColors(hab) <- paste(c("#FFFFFF",brewer.pal(8,"Greys")),c("00",rep("FF",8)),sep="")
#'
#' #dev(4)
#' Plot(hab,new=TRUE,speedup=3) # note speedup is equivalent to making pyramids,
#'                              # so, some details are lost
#'
#' # initiate 10 fires at to loci
#' fires <- spread(hab, loci=as.integer(sample(1:ncell(hab), 10)),
#'                 0.235, 0, NULL, 1e8, 8, 1e6, mapID=TRUE)
#' #set colors of raster, including a transparent layer for zeros
#' setColors(fires, 10)<-c("#00000000", brewer.pal(8,"Reds")[5:8])
#' Plot(fires)
#' Plot(fires,addTo="hab")
#'
#' #alternatively, set colors using cols= in the Plot function
#' Plot(hab,new=TRUE)
#' Plot(fires) # default color range makes zero transparent.
#' # Instead, to give a color to the zero values, use \code{zero.color=}
#' Plot(fires, addTo="hab",
#'      cols=colorRampPalette(c("orange","darkred"))(10))
#' hab2 <- hab
#' Plot(hab2)
#' Plot(fires, addTo="hab2$hab", zero.color="white",
#'      cols=colorRampPalette(c("orange","darkred"))(10))
#' # or overplot the original (NOTE: legend stays at original values)
#' Plot(fires,
#'      cols=topo.colors(10))
#'
setMethod("spread",
          signature(landscape="RasterLayer"),
          definition = function(landscape, loci, spreadProbPixel, persistence,
                                mask, maxSize=rep_len(ncell(landscape), length(loci)),
                                directions=8L, iterations = NULL, mapID=FALSE,
                                plot.it=FALSE, spreadProbCluster, dist, ...) {
            ### should sanity check map extents
            if (is.null(loci))  {
              # start it in the centre cell
              loci <- (nrow(landscape)/2L + 0.5) * ncol(landscape)
            }

            if(is(spreadProbPixel,"RasterLayer")) {
              if (minValue(spreadProbPixel)>1L) stop("spreadProbPixel is not a probability")
              if (maxValue(spreadProbPixel)<0L) stop("spreadProbPixel is not a probability")
            } else {
              if (!inRange(spreadProbPixel)) stop("spreadProbPixel is not a probability")
            }

            ## Recycling maxSize as needed
            maxSize <- rep_len(maxSize, length(loci))

            spreads <- vector("integer", ncell(landscape))

            n <- 1L
            if (mapID) {
              spreads[loci] <- 1L:length(loci)
              if(length(maxSize) > 1L){
                size <- rep_len(1L, length(loci))
              } else {
                size <- length(loci)
              }
            } else {
              spreads[loci] <- n
              size <- length(loci)
            }

            # Convert mask and NAs to 0 on the spreadProbPixel Raster
            if (is(spreadProbPixel, "Raster")) {
              spreadProbPixel[is.na(spreadProbPixel)]<-0L
              if(!is.null(mask)) {
                spreadProbPixel[mask==1L]<-0L
              }
            } else if (is.numeric(spreadProbPixel)) { # Translate numeric spreadProbPixel into a Raster
              #  if there is a mask Raster
              if(!is.null(mask)) {
                spreadProbPixel <- raster(extent(landscape), res=res(landscape), vals=spreadProbPixel)
                spreadProbPixel[mask==1L]<-0L
              }
            }

            while (length(loci)) { # while there are active cells

              # identify neighbours
              if (mapID) {
                potentials <- adj(landscape, loci, directions, pairs=TRUE)
              } else {
                # must pad the first column of potentials
                potentials <- cbind(NA, adj(landscape, loci, directions,
                                            pairs=FALSE))
              }

              # keep only neighbours that have not been spread to yet
              potentials <- potentials[spreads[potentials[,2L]]==0L,,drop=FALSE]


              if (is.numeric(spreadProbPixel)) {
                spreadProbs <- spreadProbPixel
              } else {
                spreadProbs <- spreadProbPixel[potentials[,2L]]
              }

              potentials <- potentials[runif(NROW(potentials)) <= spreadProbs,,drop=FALSE]
              potentials <- potentials[sample.int(NROW(potentials)),,drop=FALSE]
              potentials <- potentials[!duplicated(potentials[,2L]),,drop=FALSE]
              events <- potentials[,2L]

              # Implement maxSize
              if(length(maxSize) == 1L){
                len <- length(events)
                if((size+len) > maxSize) {
                  keep <- len - ((size+len) - maxSize)
                  samples <- sample(len,keep)
                  events <- events[samples]
                  potentials <- potentials[samples,,drop=FALSE]
                }
                size <- size + length(events)
              } else {
                len <- tabulate(spreads[potentials[,1L]], length(maxSize))
                if(any((size + len) > maxSize & size < maxSize)){
                  whichID <- which(size + len > maxSize)
                  toRm <- (size + len)[whichID] - maxSize[whichID]

                  for(i in 1:length(whichID)){
                    thisID <- which(spreads[potentials[,1L]] == whichID[i])
                    potentials <- potentials[-sample(thisID, toRm[i]),,drop = FALSE]
                  }
                  events <- potentials[,2L]
                }
                size <- pmin(size + len, maxSize) ## Quick? and dirty, fast but loose (too flexible)
              }

              size <- size + length(unique(events))

              # update eligibility map

              n <- n+1L

              if (mapID) {
                spreads[events] <- spreads[potentials[,1L]]
              } else {
                spreads[events] <- n
              }

              if(length(maxSize) > 1L){
                if(exists("whichID")){
                  events <- events[!spreads[events] %in% whichID]
                  rm(whichID)
                }

              } else {
                if(size >= maxSize) {
                  events <- NULL
                }
              }

              # drop or keep loci
              if (is.null(persistence) | is.na(persistence) | persistence == 0L) {
                loci <- NULL
              } else {
                if (inRange(persistence)) {
                  loci <- loci[runif(length(loci))<=persistence]
                } else {
                  # here is were we would handle methods for raster* or functions
                  stop("Unsupported type: persistence")
                }
              }

              loci <- c(loci, events)

              if (plot.it){
                plotCur <- raster(landscape)
                plotCur <- setValues(plotCur,spreads)
                Plot(plotCur, ...)
              }
            }

            # Convert the data back to raster
            spre <- raster(landscape)
            spre <- setValues(spre, spreads)
            return(spre)
          }
)




##############################################################
#' Simulate a seedDispRcv process on a landscape.
#'
#' Simulate seed dispersal using user defined function. This is a "receiving pixel" focused dispersal approach.
#' It is the "potentially receiving" cell that looks around itself for potential seed sources. If it finds
#' a single seed source, that passes the probability function described by the dispersalFn, then the
#' cluster ends and the receiving cell index is returned as part of a vector of indices of all
#' successfully cells that received seeds. This function can therefore only be used for a relatively
#' specific situation where there is a yes/no returned for each potential receiving cell, i.e., not abundance.
#' This function is also not cumulative, i.e,. there is no higher abundance of seeds received if
#' a receiving cell has lots of seed sources around it vs. a single seed source. The difference will
#' come with a higher probability of successfully receiving a "seed".
#'
#' \code{dispersalFn} must be an expression that returns a probability distribution. Because
#' it is a dispersal kernal, it must be a probability distribution. The expression that can
#' take an argument named "dis" (without quotes) as this will be calculated internally and
#' represents the distance from the initial (receiving) pixel and all active pixels within that
#' cluster of active pixels. \code{SpaDES} includes the \code{\link{Ward}} kernel as defined in the
#' Landis documentation.
#'
#' @param seedSrc  A \code{RasterLayer} object where pixels indicate the presence (or abundance) of seed source
#' pixels
#'
#' @param seedRcv  A \code{RasterLayer} object where pixels indicate the potential pixels to receive seeds
#'
#' @param dispersalFn  An expression that can take a "dis" argument. See details. Default is "Ward"
#'
#' @param plot.it  If TRUE, then plot the raster at every iteraction, so one can watch the
#' seedDispRcv event grow.
#' @param effDist Landis species- and ecoregion-specific effective distance parameter
#'
#' @param maxDist  Landis species- and ecoregion-specific effective distance parameter
#'
#' @param b  Landis ward seed dispersal calibration coefficient (set to 0.01 in Landis)
#'
#' @param k  Landis ward seed dispersal the probability that seed will disperse within
#' the effective distance (eg., 0.95)
#'
#' @param ...   Additional parameters. Currently none
#'
#' @return A numeric vector of raster pixel indices, in the same resolution and extent as
#' \code{seedSrc} raster.
#'
#' @import data.table
#' @import raster
#' @import dplyr
#' @export
#' @docType methods
#'
#' @author Eliot McIntire
#'
#' @name seedDispRcv
#' @aliases seedDispRcv
#' @rdname seedDispRcv
setGeneric("seedDispRcv", function(seedSrc, seedRcv=seedSrc,
                                   dispersalFn=Ward,
                                   effDist=100, maxDist=150, b=0.01, k=0.95,
                                   plot.it=FALSE, ...) {
  standardGeneric("seedDispRcv")
})

#' @rdname seedDispRcv
#' @examples
#' library(raster)
#'
#' # Make random forest cover map
#' a <- raster(extent(0,1e4,0,1e4),res=100)
#' hab <- gaussMap(a,speedup=1) # if raster is large (>1e6 pixels), use speedup>1
#' names(hab)="hab"
#'
#' seedSrc <- hab>5
#' setColors(seedSrc,1) <- c("white","black")
#'
#' seedRcv <- hab>5
#' system.time(seeds <- seedDispRcv(seedSrc, seedRcv=seedRcv,
#'   maxDist=250, plot.it=TRUE))
#' seedRcvRaster <- raster(seedSrc)
#' if(length(seeds)>0) {
#'   seedRcvRaster[seeds] <- 1
#'   Plot(seedRcvRaster, cols="black")
#' }
setMethod("seedDispRcv",
          signature(seedSrc="RasterLayer"),
          definition = function(seedSrc, seedRcv, dispersalFn,
                                effDist, maxDist, b, k,
                                plot.it=FALSE, ...) {
            cellSize=unique(res(seedSrc))

            seedSrcVec <- getValues(seedSrc)
            seedRcv <- Which(seedRcv>0, cells=TRUE)
            if(length(cellSize)>1) stop("seedSrc resolution must be same in x and y dimension")
            ### should sanity check map extents
            if (is.null(seedRcv))  {
              # start it in the centre cell
              seedRcv <- (nrow(seedSrc)/2L + 0.5) * ncol(seedSrc)
            }
            lociReturn <- data.table(fromInit=seedRcv,key="fromInit")
            seedsArrived <- data.table(fromInit=numeric(),key="fromInit")

            if(plot.it) {
              wardSeedDispersalHab1 <- raster(seedSrc)
              wardSeedDispersalHab1[] <- NA
              assignGlobal("wardSeedDispersalHab1",wardSeedDispersalHab1)
              Plot(seedSrc, new=TRUE)
            }

            n <- cellSize

            potentials <- data.table("fromInit"=seedRcv,key="fromInit")
            potentials[,from:=fromInit]
            setkey(potentials,"from", "fromInit")

            while (length(seedRcv) & (n<=maxDist)) { # while there are active cells and less than maxDistance

              # identify neighbours
              adjCells <- adj(seedSrc, seedRcv, directions=8, pairs=TRUE) %>%
                data.table(key="from")
              if(n>cellSize) {
                # replace "from" column with the values from the previous "to" column
                potentials[,`:=`(from=NULL,dis=NULL)][,from:=to][,to:=NULL]
                setkey(potentials,"from", "fromInit")
              }
              potentials <- potentials[adjCells, allow.cartesian=TRUE]

              if(plot.it) {
                wardSeedDispersalHab1[potentials[,from]] <- n
                assignGlobal("wardSeedDispersalHab1",wardSeedDispersalHab1)
                Plot(wardSeedDispersalHab1, addTo="seedSrc")
              }


              # Section - omit cells based on one of three criteria
              # 1. Can't spread backwards, within a cluster
              # keep only neighbours that have not been seedDispRcv to yet, within each
              # cluster. This means that a cell can't seedDispRcv backwards, but two different
              # clusters can be on the same cell


              potentials <- potentials[from!=to,.SD,by="fromInit"] %>%

              # 2. Can't have more than one "arrival" in a potential "to" cell, by cluster
              # Don't know how to do next within data.table syntax - remove duplicate "to"
              #  within a cluster
                unique(., by=c("fromInit", "to"))
              #potentials  <- potentials %>%
              #  group_by(fromInit) %>%
              #  filter(!duplicated(to))

              # 3. remove any that are not within a 1 unit doughnut of
              # discard those that more than "n" units from a "from" cell. This keeps spreading
              #   in a circle. It is somewhat wasteful, because the distances are calculated above
              #   and then deleted here, but this may be the most efficient way
              nr <- NROW(potentials)

              xys <- xyFromCell(seedSrc, as.matrix(potentials[,list(fromInit,to)]))
              potentials[,dis:=pointDistance(xys[1:nr,], xys[(nr+1):(2*nr),], lonlat=FALSE)]
              #potentials <- potentials[((n-cellSize) < dis) & (dis <= n),]
              potentials <- potentials[abs(dis - n)<=(n-cellSize),]

              browser()

              # for speeding up. If no pixels within the doughnut are a seed source,
              #  just skip next block
              potentialsWithSeed <- as.logical(seedSrcVec[potentials[,to]])
              if(any(potentialsWithSeed)) {

                potentialsWithSeedDT  <- potentials[potentialsWithSeed,]
                nr <- NROW(potentialsWithSeedDT)
                setkey(potentialsWithSeedDT, "fromInit")

                potentialsWithSeedDT[,receivesSeeds:=runif(nr)<eval(dispersalFn)]
                receivedSeeds <- potentialsWithSeedDT[,any(receivesSeeds), by="fromInit"]

                #drop any that received seeds from potentials, as they are now in lociReturn
                if(NROW(receivedSeeds[V1==TRUE])>0) {
                  seedsArrived <- rbindlist(list(seedsArrived,lociReturn[receivedSeeds[V1==TRUE]][,V1:=NULL]))
                  setkey(seedsArrived, "fromInit")
                  setkey(potentials, "fromInit")
                  potentials <- potentials[!seedsArrived]
                }
              }

              n <- n+cellSize

              # refresh so that "to" cells become new "from" cells
              seedRcv <- potentials[,to]

            }
            return(seedsArrived$fromInit)

          }
)

##############################################################
#' Ward Seed Dispersal kernel
#'
#' A probability distribution used in Landis.
#'
#' @export
#' @docType methods
#'
#' @author Eliot McIntire
#'
#' @name Ward
#' @rdname Ward
Ward <- expression(if(cellSize<=effDist) {
  ifelse(dis<=effDist,
         exp((dis-cellSize)*log(1-k)/effDist)-
           exp(dis*log(1-k)/effDist),
         (1-k)*exp((dis-cellSize-effDist)*log(b)/maxDist)-
           (1-k)*exp((dis-effDist)*log(b)/maxDist))
} else {
  ifelse(dis<=cellSize,
         exp((dis-cellSize)*log(1-k)/effDist)-(1-k)*
           exp((dis-effDist)*log(b)/maxDist),
         (1-k)*exp((dis-cellSize-effDist)*log(b)/maxDist)-
           (1-k)*exp((dis-effDist)*log(b)/maxDist))
})


#' Simulate a seedDispRcv2 process on a landscape.
#'
#' Simulate seed dispersal using user defined function. This is a "receiving pixel" focused dispersal approach.
#' It is the "potentially receiving" cell that looks around itself for potential seed sources. If it finds
#' a single seed source, that passes the probability function described by the dispersalFn, then the
#' cluster ends and the receiving cell index is returned as part of a vector of indices of all
#' successfully cells that received seeds. This function can therefore only be used for a relatively
#' specific situation where there is a yes/no returned for each potential receiving cell, i.e., not abundance.
#' This function is also not cumulative, i.e,. there is no higher abundance of seeds received if
#' a receiving cell has lots of seed sources around it vs. a single seed source. The difference will
#' come with a higher probability of successfully receiving a "seed".
#'
#' \code{dispersalFn} must be an expression that returns a probability distribution. Because
#' it is a dispersal kernal, it must be a probability distribution. The expression that can
#' take an argument named "dis" (without quotes) as this will be calculated internally and
#' represents the distance from the initial (receiving) pixel and all active pixels within that
#' cluster of active pixels. \code{SpaDES} includes the \code{\link{Ward}} kernel as defined in the
#' Landis documentation.
#'
#' @param seedSrc  A \code{RasterLayer} object where pixels indicate the presence (or abundance) of seed source
#' pixels
#'
#' @param seedRcv  A \code{RasterLayer} object where pixels indicate the potential pixels to receive seeds
#'
#' @param dispersalFn  An expression that can take a "dis" argument. See details. Default is "Ward"
#'
#' @param plot.it  If TRUE, then plot the raster at every iteraction, so one can watch the
#' seedDispRcv2 event grow.
#' @param effDist Landis species- and ecoregion-specific effective distance parameter
#'
#' @param maxDist  Landis species- and ecoregion-specific effective distance parameter
#'
#' @param b  Landis ward seed dispersal calibration coefficient (set to 0.01 in Landis)
#'
#' @param k  Landis ward seed dispersal the probability that seed will disperse within
#' the effective distance (eg., 0.95)
#'
#' @param ...   Additional parameters. Currently none
#'
#' @return A numeric vector of raster pixel indices, in the same resolution and extent as
#' \code{seedSrc} raster.
#'
#' @import data.table
#' @import raster
#' @import dplyr
#' @export
#' @docType methods
#'
#' @author Eliot McIntire
#'
#' @name seedDispRcv2
#' @aliases seedDispRcv2
#' @rdname seedDispRcv2
setGeneric("seedDispRcv2", function(seedSrc, seedRcv=seedSrc,
                                   dispersalFn=Ward,
                                   effDist=100, maxDist=150, b=0.01, k=0.95,
                                   plot.it=FALSE, ...) {
  standardGeneric("seedDispRcv2")
})

#' @rdname seedDispRcv2
#' @examples
#' library(raster)
#'
#' # Make random forest cover map
#' a <- raster(extent(0,1e4,0,1e4),res=100)
#' hab <- gaussMap(a,speedup=1) # if raster is large (>1e6 pixels), use speedup>1
#' names(hab)="hab"
#'
#' seedSrc <- hab>5
#' setColors(seedSrc,1) <- c("white","black")
#'
#' seedRcv <- hab>5
#' system.time(seeds <- seedDispRcv2(seedSrc, seedRcv=seedRcv,
#'   maxDist=250, plot.it=TRUE))
#' seedRcvRaster <- raster(seedSrc)
#' if(length(seeds)>0) {
#'   seedRcvRaster[seeds] <- 1
#'   Plot(seedRcvRaster, cols="black")
#' }
setMethod("seedDispRcv2",
          signature(seedSrc="RasterLayer"),
          definition = function(seedSrc, seedRcv, dispersalFn,
                                effDist, maxDist, b, k,
                                plot.it=FALSE, ...) {
            cellSize=unique(res(seedSrc))
            seedRcv <- Which(seedRcv>0, cells=TRUE)
            if(length(cellSize)>1) stop("seedSrc resolution must be same in x and y dimension")
            ### should sanity check map extents
            if (is.null(seedRcv))  {
              # start it in the centre cell
              seedRcv <- (nrow(seedSrc)/2L + 0.5) * ncol(seedSrc)
            }
            lociReturn <- data.table(fromInit=seedRcv,key="fromInit")
            seedsArrived <- data.table(fromInit=numeric(),key="fromInit")

            if(plot.it) {
              wardSeedDispersalHab1 <- raster(seedSrc)
              wardSeedDispersalHab1[] <- NA
              assignGlobal("wardSeedDispersalHab1",wardSeedDispersalHab1)
              Plot(seedSrc, new=TRUE)
            }

            n <- cellSize

            potentials <- data.table("fromInit"=seedRcv,key="fromInit")
            potentials[,from:=fromInit]
            setkey(potentials,"from", "fromInit")

            while (length(seedRcv) & (n<=maxDist)) { # while there are active cells and less than maxDistance

              # identify neighbours
              adjCells <- adj(seedSrc, seedRcv, directions=8, pairs=TRUE) %>%
                data.table(key="from")
              if(n>cellSize) {
                # replace "from" column with the values from the previous "to" column
                potentials[,`:=`(from=NULL,dis=NULL)][,from:=to][,to:=NULL]
                setkey(potentials,"from", "fromInit")
              }
              potentials <- potentials[adjCells, allow.cartesian=TRUE]

              if(plot.it) {
                wardSeedDispersalHab1[potentials[,from]] <- n
                assignGlobal("wardSeedDispersalHab1",wardSeedDispersalHab1)
                Plot(wardSeedDispersalHab1, addTo="seedSrc")
              }


              # Section - omit cells based on one of three criteria
              # 1. Can't spread backwards, within a cluster
              # keep only neighbours that have not been seedDispRcv2 to yet, within each
              # cluster. This means that a cell can't seedDispRcv2 backwards, but two different
              # clusters can be on the same cell
              potentials <- potentials[from!=to,.SD,by="fromInit"] %>%

                # 2. Can't have more than one "arrival" in a potential "to" cell, by cluster
                # Don't know how to do next within data.table syntax - remove duplicate "to"
                #  within a cluster
                #potentials  <- potentials %>%
                group_by(fromInit) %>%
                filter(!duplicated(to))

              # 3. remove any that are not within a 1 unit doughnut of
              # discard those that more than "n" units from a "from" cell. This keeps spreading
              #   in a circle. It is somewhat wasteful, because the distances are calculated above
              #   and then deleted here, but this may be the most efficient way
              nr <- NROW(potentials)
              xys <- xyFromCell(seedSrc, as.matrix(potentials[,list(fromInit,to)]))
              potentials[,dis:=pointDistance(xys[1:nr,], xys[(nr+1):(2*nr),], lonlat=FALSE)]
              potentials <- potentials[((n-cellSize) < dis) & (dis <= n),]

              # for speeding up. If no pixels within the doughnut are a seed source,
              #  just skip next block
              potentialsWithSeed <- as.logical(seedSrc[potentials[,to]])
              if(any(potentialsWithSeed)) {

                potentialsWithSeedDT  <- potentials[potentialsWithSeed,]
                nr <- NROW(potentialsWithSeedDT)
                setkey(potentialsWithSeedDT, "fromInit")

                potentialsWithSeedDT[,receivesSeeds:=runif(nr)<eval(dispersalFn)]
                receivedSeeds <- potentialsWithSeedDT[,any(receivesSeeds), by="fromInit"]

                #drop any that received seeds from potentials, as they are now in lociReturn
                if(NROW(receivedSeeds[V1==TRUE])>0) {
                  seedsArrived <- rbindlist(list(seedsArrived,lociReturn[receivedSeeds[V1==TRUE]][,V1:=NULL]))
                  setkey(seedsArrived, "fromInit")
                  setkey(potentials, "fromInit")
                  potentials <- potentials[!seedsArrived]
                }
              }

              n <- n+cellSize

              # refresh so that "to" cells become new "from" cells
              seedRcv <- potentials[,to]

            }
            return(seedsArrived$fromInit)

          }
)

